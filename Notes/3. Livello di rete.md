# Livello di rete
## Introduzione
Il **livello di rete** si occupa principalmente di individuare un **percorso** tra un computer *mittente* e un computer *destinazione* e di trasmettere i pacchetti dalla sorgente alla destinazione attraversando diversi router. La ricerca del percorso (*routing* o *instradamento*) si basa su una **tabella di instradamento** preparata manualmente o automaticamente.
I router si occupano della spedizione dei pacchetti in base all’indirizzo indicato. Esistono, quindi, delle **tabelle di routing** che permettono di scoprire subito dove spedire il pacchetto.
## Datagram e Circuiti virtuali
All’interno del livello di rete ci sono due diversi servizi per l’instradamento dei pacchetti:
- **Datagram**.
In datagram, ogni pacchetto contiene al suo interno l’indirizzo di destinazione completo e ogni “nodo nella rete” effettua le operazioni di routing (capire la strada migliore per giungere a destinazione). Sostanzialmente, ogni pacchetto contiene un indirizzo di destinazione e uno di arrivo che non è detto che siano necessariamente uguali a quelli precedenti o successivi. Per questo motivo, i pacchetti possono prendere strade diverse e arrivare in modo non ordinato o non arrivare, spetterà ai livelli superiori effettuare i vari controlli.
Si noti che in genere, datagram tende ad appensantire il lavoro dei router (*contro*). Tuttavia (*pro*), con datagram, se un router dovesse guastarsi, verrebbero persi esclusivamente i pacchetti passanti per quel punto (i quali potranno essere recuperati successivamente non appena il sistema nota la perdita).
- **Circuito virtuale**.
Nei circuiti virtuali il tipo di indirizzamento è lo stesso del datagram ma il calcolo del percorso migliore viene effettuato solo all’inizio. In particolare, durante il calcolo del percorso, svolge un ruolo fondamentale un particolare “*pacchetto esploratore*” che è l’unico nei circuiti virtuale a contenere l’indirizzo di destinazione completo come in datagram (i pacchetti successivi non dovranno conoscere la destinazione ma il percorso tracciato dal pacchetto esploratore). Quindi, in un sistema a circuito virtuale si crea un tubo di flusso tra le macchine sorgente e destinazione con tutti i router attraversati. Il vantaggio è che i pacchetti seguiranno sempre quella strada.

Si noti che attraverso i circuiti virtuali, esistono diversi benefici (*pro*), ovvero: ($i$) un circuito virtuale è più semplice e veloce e le info vengono associate tramite id ad una tabella; ($ii$) il controllo di congestione è semplificato poiché ogni pacchetto si assicura all'inizio delle risorse interne al router.
Purtroppo un grande svataggio dei circuiti virtuali si basa sul fatto che se un router ha un problema, allora l'intero percorso deve essere ricalcolato.

## Indirizzi IPv4
Un indirizzo **IPv4** è un indirizzo a $32$ byte, il che indica un valore al più pari a $4$ miliardi. Gli indirizzi IPv4 furono distinti (per intervalli) in $5$ classi: $A$, $B$, $C$, $D$ ed $E$.
In generale, possiamo distinguere due parti di un indirizzo: 
- La parte di **rete**, all'interno della quale si svolgono operazioni di routing;
- La parte di **host**, riferita alla *LAN*.
Si noti che la differenza tra le varie classi di indirizzi si basa essenzialmente sul *numero di bit dedicati alla rete*, i quali saranno in numero via via maggiore da $A$ verso $E$.
Esistono alcuni **indirizzi speciali**, come per esempio `255.255.255.255` (formato da soli $1$ in binario), il quale indica il **broadcast**.

Com'è formato un **pacchetto** IPv4? Un pacchetto con indirizzo IPv4 assume una determinata struttura. Idealmente, il pacchetto può essere suddiviso in **righe**:

- *Riga 1*, dedicata all'**intestazione** contiene:
	- **Versione**, un campo di $4 \, bit$, utili a specificare la versione del protocollo IP; necessario poiché differenti versioni di IP (i.e IPv4 ed IPv6 posseggono diversi formati di datagramma).
	- **Dimensione dell'intestazione**, un campo di $4 \, bit$, utile a specificare dove finisce l'intestazione ed iniziano effettivamente i dati.
	- **Tipo di servizio**, un campo di $8 \, bit$,  utile a distinguere i diversi tipi di datagramma.
	- **Lunghezza del datagramma**, ovvero la lunghezza totale del datagramma, intestazione più dati. Pur essendo formato da un $16 \, bit$, quindi in grado di rappresentare una dimensione massima uguale a $65\,535 \, byte$ spesso, per non superare la dimensione massima per Ethernet, i datagrammi non superano i $1500 \, byte$.
- *Riga 2*, dedicata principalmente alla **frammentazione** contiene:
	- **ID** del datagram, utile per la frammentazione);
	- **Flags** (i.e. DF, MF);
	- **Offset di frammentazione**, un campo di $13 \, bit$ per indicare la posizione del frammento all’interno dell’intera sequenza.
- *Riga 3*, contiene:
	- **TTL**, ossia un contatore di salti che viene decrementato da ogni router e che se zero lo scarto di quest'ultimo (in altre parole, *TTL* indica il “*tempo di vita massimo di un pacchetto*”);
	- **Protocollo di trasporto utilizzato**, un campo riservato per l'omonima funzione (e.g. TCP o UDP);
	- “**Header Checksum**”, ossia un checksum del preambolo presente nella prima riga (utile per verificare la presenza di errori).
- *Riga 4*
	-  **Indirizzo sorgente**, un campo a $32 \,bit$; 
-  *Riga 5*
	-  **Indirizzo di destinazione**, un campo a $32 \,bit$; 
- *Riga 6*
	-  **Options**, un campo facoltativo (se vuoto HTL=0);
- *Riga 7*
	-   **Data**, un campo contenente il payload, ovvero i dati, spesso il pacchetto al livello di trasporto (dati applicativi e intestazione del protocollo di trasporto).

> Le prime 5 righe misurano $20 \, byte$, aggiungendo i parametri *TCP* (non considerando il campo option) la dimensione finale sarà $40 \, byte$ ($28$ usando *UDP*)

![[ipv4.png]]

### Frammentazione
Se un pacchetto di dimensione $N$ arriva ad un router e deve essere trasmesso su un link di uscita con MTU < N, allora il pacchetto dovrà essere *frammentato* e *ricostruito* nella macchina di destinazione.
> MTU è acronimo di *Maximum Transfer Unit* ovvero la dimensione massima della frame che può viaggiare a livello DLL.

I frammenti appartenenti allo stesso pacchetto presentano lo stesso **ID**; l’**offset** ci permette di capire dove si pone il frammento rispetto all’origine.
E' importante notare che i flag descritti all'interno della seconda riga coprono un ruolo relativo alla frammentazione. Infatti, relativamente a **DF** (i.e. *don't fragment*), questo indica se il pacchetto può essere frammentato o meno, mentre **MF** (i.e. *more fragment*) indica se il determinato frammento è l'ultimo della sequenza di frammenti.

### Indirizzamento IPv4
Generalmente un host ha un solo collegamento con la rete; quando un host vuole inviare un datagramma, lo fa su qeust'ultimo collegamento. Il confine tra l'host ed il collegamento (fisico) è detto **interfaccia**. 
Un router, differentemente da un host, poiché ha il compito di ricevere i datagrammi da una parte ed inoltrarli dall'altra, necessita di almento $2$ interfacce.
Chi possiede un indirizzo IP univoco non è l'host o il router bensì l'interfaccia.

Un **indirizzo** IP di tipo IPv4 è un indirizzo lungo $4 \, byte$ e viene solitamente rappresentato attraverso la **notazione decimale puntata**, in cui ogni $byte$ viene suddiviso dal simbolo `.` e rappresentato nella sua forma decimale.

I seguenti **indirizzi** IPv4 sono stati riservati a specifiche funzioni:
- $0.0.0.0$, un indirizzo inizialmente non valido e da non utilizzare ma nel tempo diventato un indirizzo che rappresenta l'host stesso;
- $0000...xxxx$, per indicare un indirizzo all'interno della stessa sottorete. E' possibile, infatti, raggiungere una macchina presente all'interno della nostra stessa sottorete attraverso l'utilizzo di un indirizzo che prevede soli $0$ a meno della parte relativa all'host. Si noti che inserire esclusivamente $255$ all'interno della parte relativo all'host implica effettuare un broadcast all'interno della sottorete.
- $255.255.255.255$, per indicare il *broadcast*, secondo cui tutte le macchine riceveranno il pacchetto. Si noti che questo indirizzo è spesso bloccato dalla maggior parte dei router.
- $127.0.0.0$ -> $127.255.255.255$, per indicare un indirizzo di loopback; quest'ultimi sono utili ad identificare realmente l'host (i.e. *this-host*). Quasi sempre si trova nel formato $127.0.0.1$, il quale indica la propria macchina.
- $169.254.0.0$ -> $169.254.255.255$, una serie di indirizzi che la macchina host può utilizzare nel momento in cui nessuno riferisce ad egli una indirizzo IP. Tecnicamente, chiamiamo quest'ultimi indirizzi *zero-conf*. Quest'ultimo non è in grado di navigare in Internet.
- $10.0.0.0$ -> $10.255.255.255$, per indicare un indirizzo IP privato, utili nel momento in cui vogliamo creare una LAN all'interno della nostra abitazione. Indirizzi di questo tipo non sono raggiungibili dal mondo esterno.
- $172.16.0.0$ -> $172.31.255.255$, e $192.168.0.0$ -> $192.168.255.255$, per indicare ancora una volta un IP privato. Indirizzi di questo tipo sono spesso forniti dai router domestici.

> Attraverso un indirizzo di loopback, i pacchetti inviati a partire dal livello applicativo verso il livello di rete, una volta arrivati a quest'ultimo livello, vengono rispediti nuovamente verso il livello applicativo.

### Maschera di sottorete
Ad un certo tempo si decise di eseguire una **maggiore suddivisione** all'interno dell'indirizzo IPv4, motivo per cui nascono le **maschere di sottorete**.
Una maschera permette di suddividere un indirizzo in **rete** più **sottorete** ed **host**, secondo cui rete più sottorete rappresentassero la parte di indirizzo all'interno della quale si effettuasse *routing*, mentre l'host indentifica la macchina stessa.

> Il compito di una maschera di sottorete è dividere in $3$ parti l'indirizzo IPv4, facilitando la ricerca e l'individuazione della macchina nella rete.

Com'è formata la maschera? Sostanzialmente, la maschera non è altro che una sequenza di $x \; bit \, 1$ seguiti da una serie di $32 - x \; bit \, 0$. In particolare, $x$ è un valore compreso tra $1$ e $31$, ed indica il numero di $bit$ *su cui non applicare la maschera*.
Se per esempio avessimo un indirizzo con maschera $23$, allora ciò indica che solo i primi $23 \, bit$ dell'indirizzo saranno visibili, il che non vale per i restanti $9$ (i quali non saranno visibili).
Una maschera di sottorete viene descritta secondo la seguente notazione: `a.b.c.d/x`.

Una maschera di sottorete viene applicata secondo un operazione di *AND* tra l'indirizzo è la maschera e permette di capire se la macchina si trova all'interno della nostra rete o fuori rispetto essa.

$$11000000.10101000.00100000.01100001 \;\; AND \;\;\;\;\;\;\;\;\;\;\;\;\;\; 192.168.032.097 \;\; AND$$
$$11111111.11111111.11111111.11100000 \;\; = \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; 255.255.255.224 \;\; =$$
$$11000000.10101000.00100000.01100000 \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; 192.168.032.096$$

> Secondo $RFC \; 3021$ è possibile utilizzare la maschera $31$ per i soli collegamenti *punto-punto*, mentre una maschera $32$, se pur in modo insensato, può essere utilizzata per un collegamento che prevede un solo indirizzo IP (i.e. non permette di comunicare "*con il resto del mondo*").

### Assegnamento di indirizzi IP
L'assegnamento degli IP era originariamente compito di una sola autorità: **IANA** (acronimo di *Internet Assigned Numbers Authority*). Con il passare del tempo Internet crebbe sempre di più, motivo per cui nascono autorità che svolgono questo compito prima a livello **regionale** (a livello di continente), ossia **RIR**, poi anche a livello **locale**, ovvero **LIR**.
L'autorità locale responsabile dell'assegnamento di indirizzi sul territorio locale italiano è **GARR-LIR**. GARR è un organizzazione italiano responsabile della gestione della rete rispetto le strutture universitarie.

## Indirizzi MAC
A livello LAN (rappresentabile da un ristretto gruppo di macchine) svolgono un ruolo di rilievo gli indirizzi MAC. Gli indirizzi MAC sono sostanzialmente degli indirizzi “*in teoria univoci ma modificabili*” assegnati alle schede di rete dal proprio produttore, il quale si riserva un blocco di indirizzi.
Indirizzi MAC sono formati da $6 \, byte$ solitamente rappresentati in formato esadecimale separando ciascun ottetto con un trattino o con i due punti. I primi $3 \, byte$ identificano il costruttore della scheda di rete.
$$00-08-74-4C-7F-1D$$
Un indirizzo MAC non fornisce nessuna informazione riguardo la posizione della macchina o la LAN di appartenenza, infatti, è scollegato dalla LAN ed è legato al solo costruttore della scheda di rete della macchina.

> All'interno di una comunicazione nel canale di una LAN non interessa l'IP ma il MAC, il quale informa su quale macchina è diretta la nostra frame (i.e. il pacchetto al livello DLL)

## Il protocollo ARP
Il protocollo **ARP** (acronimo di *Address Resolution Protocol*) è un protocollo al livello **rete** il cui scopo è ottenere l'indirizzo MAC di una macchina di cui è noto l'indirizzo IP. 
Un pacchetto IP, infatti, può arrivare a destinazione solo se è noto l'indirizzo MAC della macchina destinataria.

> Possiamo definire il protocollo ARP come un "*traduttore*" da IP a MAC.

Il mittente, che vuole conoscere l'indirizzo MAC del destinatario a partire dall'indirizzo IP di quest'ultimo, invia una `ARP REQUEST` in broadcast, utilizzando $FF-FF-FF-FF-FF-FF$ come indirizzo MAC. In questo modo, tutte le schede di rete riceveranno il messaggio ma l'unico a rispondere sarà la macchina con l'indirizzo IP uguale a quello descritto nell'`ARP REQUEST`.
Ogni coppia `IP-MAC` verrà conservata all'interno di una tabella (i.e `ARP CACHE`), quest'ultima contenente le colonne relative a IP, MAC e TTL, quest'ultimo un timer utile a scartare informazioni troppo vecche.
Questa tabella fungerà da cache per gli indirizzi MAC, e per questo sarà caratterizzata dalla poca memoria e la necessità di processi di rimozione e aggiunta (e.g. strategia FIFO).
Per ovvi motivi, prima di ogni `ARP REQUEST`, ogni host controlla che questa non sia già presenta all'interno della propria `ARP CACHE`.
$$ $$
Come funziona tecnicamente il protocollo ARP? Essenzialmente il protocollo presenta $3$ fasi: 
1. `ARP REQUEST`, una richiesta in cui viene inserito all'interno della *FROM* l'indirizzo IP di cui si vuole conoscere l'indirizzo MAC ed il suo indirizzo MAC proprietario; nella sezione *TO* l'indirizzo MAC $FF-FF-FF-FF-FF-FF$. In questo verrà effettuata una broadcast, motivo per cui tutti analizzeranno la richiesta ed una sola macchina sarà colei che non scarterà la frame (poichè "*proprietaria*" dell'indirizzo IP nella FROM).
2. `ARP REPLY`, secondo cui la macchine che non scarta la frame può rispondere, comunicando il suo indirizzo MAC. Egli inserisce il proprio IP ed indirizzo MAC all'interno della *FROM*, mentre inserisce i dati del precedente mittente all'interno della sezione *TO*.
3. In seguito alla risposta, l'informazione precedentemente non conosciuta verrà conservata all'interno di `ARP CACHE`.

$$ $$
$$ARP Request: \; From: \, 192.168.0.1 \, (00:00:1A:3E:43:55) \; To: \, 192.168.0.3 \, ( FF:FF:FF:FF:FF:FF )$$
$$ARP Reply: \; From: \, 192.168.0.3 \, ( D1:01:CA:13:37:B7 ) \; To: \, 192.168.0.1 \, (00:00:1A:3E:43:55)$$
$$ $$

I **problemi** di ARP sono rappresentati dalle sue gravi falle di sicurezza, infatti:
- ARP **non richede autenticazione**, motivo per cui l'host che invia una richiesta deve "fidarsi" che l'indirizzo MAC arrivato sia effettivamente del leggittimo proprietario, il che crea le premesse per numerose vulnerabilità;
- ARP è **stateless**, il che indica che un `ARP REPLY` possa non essere conseguenza di alcuna `ARP REQUEST`, ancora una volta premessa di notevoli attacchi;
- Un host che riceve un pacchetto ARP, deve sempre aggiornare la sua `ARP CACHE`.

## Altri protocolli
### RARP
Il protocollo **RARP** (acronimo di *Reverse Address Resolution Protocol*), che differentemente da ARP non è un protocollo distribuito, è un protocollo usato per risalire all'indirizzo IP conoscendo l’indirizzo fisico (MAC).
Il suo funzionamento si basa su un server RARP che associa un indirizzo MAC ad un indirizzo IP. L'utilizzo di questo server è anche il motivo del suo scarso utilizzo.

### BOOTP
Il protocollo **BOOTP** è un protocollo che permette l'installazione di un sistema operativo su una macchina tramite rete; il tutto a partire dalla conoscenza dell'indirizzo MAC di quest'ultima macchina (per questo motivo, BOOTP è spesso utilizzato insieme a RARP).
Il trasferimento avviene tramite **TFTP** (una versione *senza autentificazione* di *FTP*).
L'utilizzo di BOOTP era fortemente legato al costo degli HDD.

## Come avviene la comunicazione?
Supponiamo che una macchina $A$ abbia la necessità di comunicare con un'altra macchina $B$, allora esistono due possibili scenari:
- $B$ si trova all'interno della stessa LAN di $A$, per cui in tal caso dovrà ottenere il MAC del destinatario per avviare la comunicazione a livello DLL, motivo per cui invia una richiesta ARP, rimanendo in attesa di risposta da parte del destinatario.
- $B$ non si trova all'interno della stessa LAN di $A$, motivo per cui la macchina $A$ indirizza il pacchetto al *router* che, leggendo il pacchetto IP crea una frame DLL da spedire verso la LAN di destinazione.

Com'è possibile per il mittente capire se il ricevente si trova all'interno della sua stessa LAN? Sostanzialmente, ciò si basa sull'applicazione di operazioni di AND e XNOR tra *indirizzi* e *maschere*. In particolare, viene effettuato:
1. L'operazione di **AND** tra l'IP del destinatario e la maschera del destinatario;
2. L'operazione di **AND** tra l'IP del destinatario e la maschera del mittente;
	- Se il risultato dell'operazione $1$ e $2$ è uguale, allora le macchine appartengono alla stessa sottorete (i.e. LAN), motivo per cui verrà effettuata una richiesta ARP.
3. L'operazione di **XNOR** (operazione per cui risultato è uguale ad $1$ se i bit sono uguali, quindi entrambi $0$ o $1$). A questo punto, se il risultato presenta una sequenza di soli $1$, allora la destinazione di trova definitivamente nella sottorete del mittente.

> Se il mittente dovesse scoprire che il destinatario si trova in un’altra LAN, dovrà comunque fare una richiesta ARP. In particolare, effettua una richiesta ARP inserendo come MAC di destinazione il router di uscita (quindi non sarà fatto in broadcast) e come indirizzo IP l’indirizzo del destinatario. A quel punto sarà il router di destinazione a effettuare nuovamente la richiesta ARP.

### Tabelle di routing
Ogni macchina, quindi non solo il router, possiede un *particolare database* chiamato **tabella di routing**, contenente *informazioni utili* per muoversi all'interno della rete. Generalmente, una tabella di routing è formata da: 
- Rete di destinazione con maschera;
- IP del router da contattare per raggiungere la destinazione;
- Una **metrica**, per capire se un uscita è più conveniente di un'altra.
- Talvolta, vi è anche un indirizzo di *loopback* ed *interfaccia*; 

Un algoritmo di routing è responsabile di riempire una tabella di routing.

## DHCP
**DHCP** (acronimo di *Dynamic Host Configuration Protocol*) è un protocollo per l'*assegnazione dinamica* di un indirizzo IP per l'host che si è appena collegato ad una *LAN plug-and-play*, il che indica che non richiede configurazione.

Ogni indirizzo IP all'interno di una LAN deve essere compatibile con la LAN stessa, ma cosa succede nel caso in cui utilizziamo un dispositivo mobile, in cui è possibile spostarsi da una LAN all'altra? Esistono $2$ **soluzioni**: ($i$) configurare manualmente il dispositivo (i.e. macchina) o ($ii$) utilizzare DHCP.

**Come funziona DHCP**? Il funzionamento di DHCP richiede l'utilizzo di un **DHCP Server** e si compone di $4$ fasi:
1. **Fase di scoperta** (alias *DHCP Discovery*), all'interno della quale la nuova macchina invia un messaggio in broadcast a cui deve rispondere i soli server DHCP. L'obiettivo all'interno di questa fase è trovare almeno un server DHCP disponibile ad offrire una configurazione. All'interno del messaggio inviato dalla nuova macchina saranno presenti i seguenti campi:
	- Un campo per l'**Indirizzo Sorgente**, inizialmente settato a $0.0.0.0:68$ (con $68$ uguale alla porta per il DHCP Client).
	- Un campo per l'**Indirizzo Destinazione**, che poichè broadcast sarà composta da $255.255.255.255:67$ (con $67$ uguale alla porta per il DHCP Server).
	- Un campo dedicato alla "**fase DHCP**" (in questo caso, contenente *DHCPDISCOVER*);
	- Un campo **yiaddr**, settato a $0.0.0.0$ che successivamente conterrà l'indirizzo offerto dal server DHCP.
	- Un campo per l'**ID** della transazione, utile nel caso in cui più macchine diverse richiedano un indirizzo IP.
2.	**Fase di offerta** (alias *DHCP Offer*), all'interno della quale il server DHCP risponde con un offerta DHCP contenente la nuova configurazione. All'interno del messaggio inviato dal server DHCP (inviato in broadcast),  saranno presenti i seguenti campi:
	- Un campo per l'**Indirizzo Sorgente**,
	- Un campo per l'**Indirizzo Destinazione**, ancora broadcast.
	- Un campo dedicato alla "**fase DHCP**" (in questo caso, contenente *DHCPOFFER*);
	- Un campo **yiaddr**, che adesso contiene l'indirizzo offerto dal server DHCP.
	- Un campo **lifetime**, che indica per quando tempo il server DHCP mette a disposizione il determinato indirizzo IP.
	- Un campo per l'**ID** della transazione, utile nel caso in cui più macchine diverse richiedano un indirizzo IP.
	- Un campo per l'**ID** del server DHCP.
3. **Fase di richiesta** (alias *DHCP Request*), all'interno della quale la macchina richiedente l'indirizzo può accettare o meno l'offerta del server DHCP. All'interno del messaggio inviato dalla nuova macchina saranno presenti i seguenti campi:
	- Un campo per l'**Indirizzo Sorgente**, inizialmente settato a $0.0.0.0:68$ (con $68$ uguale alla porta per il DHCP Client).
	- Un campo per l'**Indirizzo Destinazione**, che poichè *broadcast* sarà composta da $255.255.255.255:67$ (con $67$ uguale alla porta per il DHCP Server).
	- Un campo dedicato alla "**fase DHCP**" (in questo caso, contenente *DHCPREQUEST*);
	- Un campo **yiaddr**, che contiene ancora l'indirizzo offerto dal server DHCP.
	- Un campo per l'**ID** della transazione, adesso incrementato.
	- Un campo per l'**ID** del server DHCP.
4. **Fase di accettazione** (alias *DHCP ACK*), secondo cui la macchine è ufficialmente autorizzata ad usare l'indirizzo IP. All'interno del messaggio inviato dalla nuova macchina saranno presenti i campi visti in precedenza; l'unico valore che cambia è il campo relativo alla fase DHCP, adesso uguale a *DHCPACK*.


Quali sono i **problemi** di DHCP? 
Il suo problema principale è dato dal timer di **lifetime**. Infatti, per un indirizzo per cui è scaduto il lifetime non esiste alcun *rilasco esplicito*, motivo per cui il client può rilasciare l'indirizzo ed effettuare una nuova richiesta DHCP oppure non far nulla.
Il server DHCP, in ogni caso, allo scadere del *lifetime* può ri-utilizzare e ri-assegnare l'IP ad un altra macchina, il che potrebbe far sì che vi siano più macchine con lo stesso indirizzo IP.

> In IPv6 è previsto il protocollo DHCP con leggere modifiche.

## NAT
A questo punto, è chiaro che ogni dispositivo che desideri comunicare in rete necessiti di un indirizzo IP. Tuttavia, la proliferazione delle sottoreti dovrebbe implicare una allocazione di indirizzi (da parte dell'ISP) per ognuna delle sottoreti, ma ciò non è possibile a causa del numero limitato di indirizzi. Per risolvere questo problema, nasce il **protocollo NAT**.

Un router abilitato al NAT non appare come router al mondo esterno, bensì come un unico dispositivo con un unico indirizzo IP. In questo modo è possibile per una sottorete utilizzare tranquillamente il proprio *spazio di indirizzamento* (i.e. i propri indirizzi privati), il quale ha senso solo per i dispositivi all'interno della sottorete; inoltre, per ovvi motivi, è permesso che più sottoreti abbiano lo stesso spazio di indirizzamento privato.

> Un router ottiene il suo indirizzo IP univoco attraverso l'utilizzo del server DHCP dell'ISP. In seguito è il router stesso a mandare in esecuzione un server DHCP che posso fornire l'indirizzo privato ad ogni macchina all'interno della sottorete.

Come **funziona** il protocollo NAT? Essenzialmente, ogni qual volta una macchina all'interno della sottorete, con il suo indirizzo privato ed un suo numero di porta, vuole comunicare in rete, egli invia un datagramma verso il router, il quale effettua la richiesta utilizzando il suo indirizzo IP (univoco) ed un numero di porta scelto dal router stesso.
Tutte queste informazioni vengono salvate all'interno di una **tabella di traduzione NAT**, all'interno del router NAT.

Supponiamo che una macchina $A$, con indirizzo $10.0.0.1$ e numero di porta $3345$, all'interno di una rete domestica voglia richiedere una pagina Web, quest'ultimo con indirizzo $128.119.40.186$ e numero di porta $80$. Dunque, la macchina $A$, con il suo indirizzo e numero di porta, invia un datagramma verso il router NAT, che genera un nuovo numero di porta $5001$.
Il router NAT, quindi, effettua la richiesta secondo il suo indirizzo IP, $138.76.29.7$, ed il numero di porta generato $5001$.

| Index | Prot. | Local IP | Local Port | Global IP | Global Port |
|--|--|--|--|--|--|
| 1 | TCP | $10.0.0.1$ | $3345$ | $138.76.29.7$ | $5001$ |

All'invio della **risposta** da parte del Web Server, il router NAT consulta la tabella di traduzione NAT usando l'indirizzo IP di destinazione ed il numero di porta di destinazione per ottenere l'indirizzo IP privato della macchina richiedente.

> Notiamo che, 

Quali sono i **problemi** di NAT? I problemi per NAT sono i seguenti: 
- Tutte le comunicazioni relative alle macchina private escono in Internet con lo stesso indirizzo IP, come se tutte le operazioni fossero state svolte da una singola macchina;
- Essendo il campo per il numero di porta lungo $16 \; bit$, il protocollo NAT può supportare al più $65\,000$ connessioni simultanee con un solo indirizzo IP. Una LAN abbastanza grande potrebbe saturare il numero di connessioni possibili, le quali potrebbero essere aumentate fornendo più indirizzi IP per lo stesso router.
- Generata una entry con una determinata porta, quest'ultima non può essere utilizzata per comunicare finchè non viene rimossa dalla tabella.
- Se la comunicazione inizia dall'esterno (e non dall'interno), il router non può capire quale sia la macchina a cui inoltrare il tutto. Per questo motivo, possiamo affermare che NAT funziona finché la comunicazione inizia dalla LAN.
### UPnP
Una soluzione all'ultimo problema di NAT è **UPnP**, un protocollo che permette alla macchina che può essere ricevere comunicazioni provenienti dall'esterno di inviare un messaggio al server NAT e richiedere il set di una riga all'interno della tabella.
In questo modo, tutte le comunicazione che iniziano dall'esterno verso il router (con una data porta) verranno inoltrate di default dal router verso la determinata macchina.
Per ovvi motivi (richiamando anche il terzo problema di NAT), nel momento in cui la macchina richiede il set di una entry con una determinata porta all'interno della tabella, quest'ultima porta non potrà più essere utilizzata da nessun altra macchina; fare ciò restituisce un errore.

## IPv6
**IPv6** nasce a causa dei **limiti** mostrati da **IPv4**, ovvero:
- L'esaurimento degli indirizzi da parte di IPv4;
- Un routing che non riflette la posizione geografica;
- L'implementazione di nuovi servizi che mostrarono dei limiti all'interno di IPv4;

Quali sono i **miglioramenti** introdotti da IPv6? 
IPv6 introduce molteplici cambiamenti rispetto IPv4, ovvero:
- **Indirizzamento esteso**, aumentando la **dimensione** dell'indirizzo IP da $32$ a $128 \, bit$; in questo modo, gli indirizzi diventano praticamente inesauribili. IPv6 supporta $3$ tipi di indirizzi: *Unicast*, *Multicast* ed *Anycast*; quest'ulimi consentono la consegna di un datagramma ad un qualsiasi host all'interno di un gruppo.
- **Intestazione ottimizzata** di $40 \, byte$, possibile attraverso la rimozione o la resa opzionale di alcuni campi presenti all'interno di IPv4. L'intestazione di lunghezza uguale a $40 \, byte$ è fissa e ciò consente una più rapida elaborazione.
- **Etichettatura dei flussi**, secondo cui viene presentato il concetto di **flusso** ed è possibile un'etichettatura di pacchetti appartenenti a flussi particolari (e.g. audio, video).

Com'è formato un **pacchetto** IPv6? Un pacchetto IPv6 può essere suddiviso in $5$ righe:
- *Riga 1*.
	- **Versione**, un campo a $4 \, bit$  che identifica il numero di versione di IP, il quale, come si può facimente immaginare, per IPv6 è uguale a $6$.
	- **Classe di traffico**, un campo ad $8 \, bit$  simile a *TOS* in IPv4, utile ad attribuire priorità ad un datagramma.
	- **Flow Label** (alias *etichetta di flusso*), un campo a $20 \, bit$  utilizzato per identificare un flusso.
- *Riga 2*.
	- **Dimensione del payload**, il quale ha sostituito il campo *Total Length*, un campo a $16 \, bit$  che indica il numero di $byte$ presenti dopo l'intestazione fissa di $40 \, byte$.
	- **Next Header** (alias *intestazione successiva*), il quale ha sostituito il campo *Protocol* ed indica il protocollo a cui verranno consegnati i dati (e.g. TCP o UDP).
	- **Hop Limit**, il quale ha sostituito TTL e rappresenta un valore che viene decrementato di $1$ ogni qual volta che il datagramma viene inoltrato da un router; se il valore raggiunge $0$, il datagramma viene eliminato.
- *Riga 3*.
	- Indirizzo IP **Sorgente**;
- *Riga 4*.
	- Indirizzo IP **Destinazione**;
- *Riga 5*.
	- *Payload* (i.e. dati).

Quali campi sono stati **rimossi**? I campi che sono stati rimossi sono:
- Campi relativi **frammentazione**, ovvero **ID**, **Flags** ed **Offset**, la quale essendo un operazione onerosa, in IPv6 non viene consentita sui router intermedi ma esclusivamente dalla sorgente o destinazione.
- **Opzioni**, ovvero **ToS** ed **Header Length**, cui rimozione ha permesso un intestazione di lunghezza fissa a $40 \, byte$.
- **Header Checksum**, poiché dal momento che protocolli a livello di trasporto e collegamento calcolano il loro checksum, si pensò fosse ridondante ed oneroso calcolare un checksum anche a livello di rete.

Quali campi sono stati **modificati**? I campi che sono stati modificati sono:
- **Total Length**, il quale diventa **Payload Length**;
- **Protocol**, il quale viene adesso gestito diversamento e diventa **Next Header**;
- **TTL**, il quale diventa **Hop Limit**;

Quali campi sono stati **aggiunti**? I campi che sono stati aggiunti sono:
- **Traffic Class**;
- **Flow Label**, aggiunto in IPv6 con l'idea di permettere un utilizzo di *circuito virtuale*; indica al router di non analizzare l'indirizzo di destinazione bensì la propria tabella per indirizzare il traffico. In questo modo, pacchetti relativi allo stesso flusso possono seguire la stessa strada in ordine. Purtroppo, Flow Label non viene molto utilizzato;

Com'è formato un **indirizzo** IPv6? Gli indirizzi IPv6 sono composti di $128 \, bit$ e sono rappresentati come $8$ gruppi, separati da due punti (`:`), di $4$ cifre esadecimali (ovvero $16 \, bit$) in cui le lettere vengono scritte in forma minuscola. Ad esempio `2001:0db8:85a3:0000:1319:8a2e:0370:7344` rappresenta un indirizzo IPv6 valido. E' possibile utilizzare notazione come `::`, i quali indicano una sequenza contigua di $0$.

Come viene **suddiviso** un indirizzo IPv6? Un indirizzo IPv6 viene suddiviso nel seguente modo:
- $001$, primi tre bit dell'indirizzo, indicano il tipo di indirizzo;
- $Global\;Routing\;Prefix$, ovvero i successivi $45 \, bit$ , indicano il *sito* (i.e. regione) a cui l'indirizzo si riferisce;
- $Subnet\;ID$, ossia i successivi $16 \, bit$, indicano la sottorete e sono utili a raggiungere velocemente la macchina di destinazione;
- $Interface\;ID$, ossia i restanti $64 \, bit$;

Com'è possibile **suddividere** gli indirizzi IPv6? Gli indirizzi IPv6 si suddividono in tre tipi di base:
- $010$, indirizzi **unicast**, che possiamo a loro volta suddividere in;
	- $1111 \, 1110 \, 10 \, ::$ ($FE80 \, ::$), indirizzi locali di **canale** (*link-local*), indica che l'indirizzo è valido esclusivamente sullo specifico link fisico e sono progettati per l'uso su un collegamento locale singolo (rete locale). Può indicare un'azienda o un ente. I router non inoltrano i pacchetti con un indirizzo di origine o di destinazione contenente un indirizzo locale di collegamento (non possono essere utilizzati in Internet).
	- $1111 \, 1110 \, 11 \, ::$ ($FEC0 \, ::$), indirizzi locali di **sito**, specifica che l'indirizzo è valido esclusivamente all'interno dell'organizzazione locale. Indirizzi *site-local* sono stati deprecati secondo $RFC \; 3879$. Non possono essere utilizzati in Internet.
	- $::1/128$, - l'indirizzo di **loopback** è un indirizzo associato al dispositivo di rete che ripete come eco tutti i pacchetti che gli sono indirizzati. Corrisponde a $127.0.0.1$ in IPv4;
	- $::$, l'indirizzo composto da tutti zeri, detto **unspecified address**, viene utilizzato per indicare *l'assenza di indirizzo* e viene utilizzato esclusivamente a livello software, corrisponde a $0.0.0.0$ in IPv4;
- $1111 \, 1111 \, ::$ ($FF00 \, ::$), indirizzi **multicast**, specifica una serie di interfacce, possibilmente in più ubicazioni. Il prefisso utilizzato per un indirizzo multicast è ff. Se un pacchetto viene inviato ad un indirizzo multicast, una copia di tale pacchetto viene distribuita ad ogni membro del gruppo. Il sistema operativo IBM i attualmente fornisce il supporto di base per l'indirizzamento multicast.;
- $1111 \, 1111 \, ::$ ($FF00 \, ::$), indirizzi **anycast**, specifica una serie di interfacce, possibilmente in diverse ubicazioni, che condividono tutte un singolo indirizzo. Un pacchetto inviato ad un indirizzo anycast è recapitato solo al membro più vicino del gruppo anycast. IBM® i può inviare indirizzi anycast, ma non può essere un membro di un gruppo unicast..

**Altri indirizzi speciali** per IPv6 sono:
- $::151.97.1.1$, un esempio di indirizzo **IPv4** mappato all'interno della gerarchia IPv6;
- $010 \, ::$, indirizzi riservati ai **service providers**;
- $100 \, ::$, indirizzi **geografici**, utilizzati per *routing*;

Quali sono gli **header opzionali** all'interno di un pacchetto IPv6? 0.  Tutte le **informazioni aggiuntive**, non previste nell’header di base, possono essere inserite utilizzando i cosiddetti **extension header**. Essi sono dei campi opzionali che pertanto sono presenti nel pacchetto solo quando necessario, a differenza di IPv4 che prevedeva eventuali opzioni aggiuntive all'interno di *Option* (il che rendeva l'header per quest'ultimo variabile). In particolare, le informazioni contenute nelle estensioni devono essere esaminate soltanto dalla sorgente e dalla destinazione, ma non dai nodi intermedi. Questo rende più veloce l’instradamento. L’unica eccezione a questa regola è costituita dall’opzione Hop-by-Hop, che contiene informazioni che devono essere esaminate da tutti i nodi lungo il cammino.    
Ogni extension header include al proprio interno un campo **Next Header** che identifica ciò che segue immediatamente dopo.
Inoltre, ogni header opzionale è caratterizzato da un valore univoco (ad esempio TCP è $6$); generalmente è preferibile seguire un ordine preciso con cui elencare i vari header opzionali.
Idealmente si forma una *lista-linkata* in cui ogni nodo contiene le informazioni e un “link” (*next-header*) che “annuncia” il tipo successivo.

Come viene gestita la **frammentazione** all'interno di IPv6? Sappiamo che in IPv4, la frammentazione avviene all'occorrenza: ogni router intermedio deve frammentare i datagram che risultano troppo grandi per attraversare il link successivo; il mittente non viene a conoscenza di tali frammentazioni intermedie. D'altra parte, con IPv6 la frammentazione viene effettuata in modalità end-to-end: la sorgente si occupa di dimensionare opportunamente i datagram e la destinazione si occupa di riassemblarli, senza alcun coinvolgimento dei router intermedi. IPv6 richiede che ogni link consenta il passaggio di pacchetti pari almeno a $1280 \, byte$.

Cosa possiamo dire rispetto la **sicurezza** all'interno di IPv6? In  IPv6 esistono $2$ specifici extension header che forniscono servizi di sicurezza: “IP Authentication Header (AH)” e “IP Encapsulation Security Payload” (ESP), parti della suite di protocolli [[8. IPSec | IPSec]].
- **IP Authentication Header** (AH) ha il compito di fornire ai datagrammi IP integrità e autenticazione, ma non confidenzialità. AH non fornisce confidenzialità affinché possa essere usato anche in luoghi dove l’importazione, l’esportazione e l’uso della crittografia è limitato. AH supporta sicurezza tra due o più host, tra due o più gateway, tra host e gateway.
- **IP Encapsulation Security Payload** (ESP) fornisce integrità, autenticazione e confidenzialità ai datagrammi IP. ESP supporta sicurezza tra due o più host, tra due o più gateway, tra host e gateway.

 Sia AH che ESP possono essere utilizzati in due modalità: Transport Mode e Tunnel Mode; nel primo caso viene fornita protezione solo ai dati, mentre nel secondo caso viene fornita protezione all'intero datagramma IP.

Com'è stata gestita la **transizione da IPv4 ad IPv6**? Se i nuovi sistemi IPv6 sono retro-compatibili e supportano IPv4, lo stesso non vale per quest'ultimo. Non è possibile aggiornare tutte le macchine con IPv4 ad IPv6, motivo per cui è necessario che anche quest'ultime dispongano di un modo per gestire pacchetti IPv6. Soluzione è stata fornita dal **tunneling**. Supponiamo che una macchina $A$ IPv6 voglia comunicare con una macchine $B$ IPv6 e per farlo debba passare per alcuni router IPv6 ed $n$ router IPv4, che chiameremo *tunnel*. Essenzialmente, secondo il tunneling, l'ultimo router IPv6 all'interno del tragitto che deve essere percorso dal datagramma IPv6 incapsula quest'ultimo (i.e. il datagramma IPv6) all'interno del campo dati di un nuovo datagramma IPv4. In seguito, il primo nodo IPv6 che decreta la fine del tunnel determinerà che il datagramma IPv4 che ha ricevuto ne contiene a sua volta uno di tipo IPv6, il tutto a partire dal numero di protocollo definito all'interno dell'omonimo campo, ossia $41$. Dunque, il nodo IPv6 estrae il pacchetto IPv6 e continua l'instradamento.
![[tunneling.png]]

### DHCP in IPv6
È simile a IPv4 ma c’è qualche differenza:
- Nella fase di *DHCP Discovery*, il messaggio è in **multicast** (il broadcast tendeva ad intasare la rete) e l’indirizzo sorgente non è più 0.0.0.0 ma è un indirizzo local-link valido (in questo modo il mittente è identificato);
- Nella fase di *DHCP Offer*, avviene in **unicast**;
- Nella fase di *DHCP Request*, avviene in **multicast**;
- Nella fase di *DHCP Ack*, avviene in **multicast**;
- I dispositivi richiedenti sono identificati dagli indirizzi **EUI-64**.


### NDP (Neighbour Discovery Protocol)
**NDP** è un protocollo introdotto con IPv6 per scoprire chi sono i *vicini* o per scoprire se ci sono router all'interno della rete locale, quindi capire come fare al meglio il routing. Inoltre, dentro NDP abbiamo inserito nativamente anche i protocollo **ARP**, ICMP e ICMP Redirect Message.

> Il protocollo ICMP (ICMPv4 ed ICMPv6) è utile ad inviare messaggi di controllo a livello di rete. Non utilizza porte e viene identificato da un codice inserito all'interno del pacchetto. Un esempio di messaggio ICMP è `ping`.

> Un datagramma IPv6 all'interno di una frame **Ethernet** prevede, all'interno della frame, che il campo Ethertype venga settato al valore: $86DD$. In questo modo, è possibile capire velocemente se la frame trasporta un datagramma di tipo IPv6 o IPv4; quest'ultime vengono riconosciute da un valore uguale a $0800$.

## Gli algoritmi di routing
Il routing è il compito fondamentale del livello di rete. Consiste nella ricerca del percorso verso una destinazione attraverso la rete.  
Gli algoritmi di routing sono eseguiti dai router per decidere su quale linea di output trasmettere i dati in ingresso e hanno come obbiettivo finale l’aggiornamento delle tabelle di routing.

Gli algoritmi di routing non sono altro che algoritmi su grafi che si possono suddividere in due categorie:
- **Statici**: il grafo (i.e. la rete) viene esaminato in un determinato istante e i percorsi vengono *calcolati* sul grafo in quel preciso momento, senza tenere conto di variazioni dei pesi all’interno della rete. L'informazione viene poi distribuita a tutti i nodi partecipanti;
- **Dinamici**: la rete viene esaminata continuamente per poter prendere le decisioni migliori; sfortunatamente, questo approccio è particolarmente oneroso in termini di risorse e tempo e potrebbe causare congestione.

Generalmente, se usati correttamente, gli algoritmi dinamici performano meglio durante il routing. Inoltre, è possibile fare un’ulteriore divisione:
- **Locali**: i nodi agiscono conoscendo solo le informazioni di nodi “vicini”. (informazioni che potrebbero non essere congrue a quelle di altri punti nella rete);
- **Globali**: si agisce avendo una visione “globale sulla rete”; il problema è che potrebbero servire troppe informazioni;

### Flooding
L'algoritmo di **flooding** rappresenta, in linea teorica, uno dei migliori algoritmi di routing e riesce a trovare la strada migliore in poco tempo senza conoscere un grosso numero di informazioni. 

Come **funziona** flooding? All’inizio, il nodo mittente invia a tutti i nodi a lui connessi una copia del pacchetto; successivamente i nodi che hanno ricevuto la copia lo inoltrano ai nodi collegati a loro (come ha fatto il mittente), *escludendo* il nodo da cui ha ricevuto il pacchetto stesso. Conseguentemente, in pochi passi, è possibile trovare il percorso migliore (poiché prova tutti i possibili percorsi). In particolare, il numero di passi risulta essere il *diametro* del grafo.

Qual è il **problema** di flooding? Il problema di flooding si basa sul fatto che la sua applicazione può far sì che due nodi possano inviarsi reciprocamente una copia, il che avviene poichè i due nodi non sono a conoscenza che l'altro ha già ricevuto una copia del pacchetto.
Per questo motivo, il numero di copie del pacchetto all'interno della rete tende a crescere fino ad inondare l'intera rete, con la possibilità che possano pure tornare al nodo di origine.

Com'è possibile **risolvere il problema** del flooding? E' necessario bloccare il routing da parte di flooding prima che quest'ultimo inondi l'intera rete, per farlo possiamo applicare una delle due soluzioni:
- Conoscendo a priori il diametro del grafo, settare un **Hop Limit** pari al diametro del grafo. Purtroppo, non è sempre semplice conoscere il diametro del grafo.
- Inserire un **ID** per ogni pacchetto, attraverso cui è possibile far capire ai nodi che i pacchetti che gli stanno arrivando sono tutte copie; questa soluzione potrebbe causare congestione ed è molta onerosa poiché ogni nodo dovrebbe tenere in memoria tutti i pacchetti che ha visto ed effettuare i vari confronti.

### Distance Vector
**Distance Vector** è un algoritmo di routing basato sull’algoritmo di **Bellman-Ford**. È una soluzione **statica** e **locale**, cui obiettivo è trovare il *cammino minimo* tra due nodi.

> Distance Vector è **distribuito**, poiché ciascun nodo riceve parte dell'informazione da uno o più dei suoi vicini; ($ii$) **auto-terminante**, poiché non vi è alcun segnale che il calcolo debba fermarsi, semplicemente si blocca; ($iii$) **asincrono**, poiché non richiede che tutti i nodi operino al passo con gli altri.

Distance Vector, come abbiamo già scritto, si basa sull'algoritmo di Bellman-Ford, quindi calcola il percorso minimo da $x$ verso ogni $y$ nel grafo secondo la nota formula di Bellman-Ford: $d_x(y) = min_v\{c(x, v) + d_v(y)\}$. Tale relazione è piuttosto intuitiva. Infatti se, dopo aver viaggiato da x a v, consideriamo il percorso a costo minimo da $v$ a $y$, il costo del percorso sarà $c(x,v) + d_v(y)$. Dato che dobbiamo iniziare viaggiando verso qualche vicino $v$, il costo minimo da $x$ a $y$ è il minimo di $c(x,v) + d_v(y)$ calcolato su tutti i nodi adiacenti $v$.

Come **funziona** Distance-Vectors? Ogni router $\mathcal{X}$ conserva una tabella di routing $D^{\mathcal{X}}()$ chiamata "*tabella delle distanze*" (i.e. una *matrice rettangolare*, a volte *quadrata*) formata da tante *righe* quanti sono i nodi presenti nella rete e tante *colonne* quante sono le possibili uscite. La distanza può essere misurata con vari tipi di **metriche**, come ad esempio il numero di salti (hop), il ritardo in millisecondi o il numero di pacchetti in coda lungo un cammino. 
*Periodicamente* i router scambiano la propria tabella delle distanze con i router vicini. Quando un router $x$ riceve da un vicino $v$ la sua tabella delle distanze, confronta per ogni destinazione $y$ la propria distanza con quella stimata dal vicino, a cui viene sommata la distanza rispetto al vicino stesso $d(x, v)$; se il secondo valore è minore, modifica la tabella di routing inserendo tale valore come distanza e la linea che porta al vicino come linea di uscita. A questo punto, se al confronto segue un aggiornamento del vettore delle distanze del nodo $x$, allora $x$ invia il proprio vettore delle distanze ai suoi vicini.

![[dv.png]]

Com'è possibile **costruire la tabella**? Ogni tabella di instradamento posseduta da un nodo $x$ (i.e. ${\mathcal{D}}_x$) è formata dal vettore delle distanze per il nodo $x$ ed i vettori delle distanze di tutti i suoi vicini $v$, quindi ${\mathcal{D}}_x = [D_x(X), \, D_x(Y), \, D_x(Z)]$.
Se volessimo calcolare la tabella per figura soprastante per il nodo $x$, quindi calcolare ${\mathcal{D}}_x$, al primo passo avremo una tabella formata da $0, 2, 7$ (uniche distanze conosciute dal nodo $x$) ed $\infty$ per le restanti distanze non conosciute.
Dopo l’inizializzazione, ciascun nodo invia il proprio vettore ai suoi vicini come mostrato dalle frecce dalla prima alla seconda colonna delle tabelle. Per esempio, il nodo $x$ invia il suo vettore delle distanze $D_x = [0, 2, 7]$ ai nodi $y$ e $z$. Dopo aver ricevuto gli aggiornamenti, i nodi ricalcolano il vettore delle distanze. Per esempio, il nodo $x$ calcola:
- $D_x(x) = 0$
- $D_x(y) = min\{c(x,y) + Dy(y), c(x,z) + Dz(y)\} = min\{2 + 0, 7 + 1\} = 2$
- $D_x(z) = min\{c(x,y) + Dy(z), c(x,z) + Dz(z)\} = min\{2 + 1, 7 + 0\} = 3$

Dopo aver ricalcolato i rispettivi vettori delle distanze, se i nodi hanno aggiornato il proprio vettore delle distanze, inviano la versione aggiornata ai propri vicini; notiamo, infatti, che solo i nodi $x$ e $z$ inviano aggiornamenti: il vettore delle distanze del nodo y non è cambiato e pertanto non è stato spedito.
Il tutto continua finché non vi è più alcun messaggio di aggiornamento.

Cosa avviene nel caso di un **miglioramento** del peso di un arco? ...

Quali sono i **problemi** di Distance Vector? Supponiamo che, dato il seguente grafo ed i seguenti vettori delle distante, ad un certo tempo $t_i$ vi sia un peggioramente del peso di un arco $(x, \, y)$, da $4$ a $60$.
0. Prima che il costo del collegamento cambi, segue $y\;\{x:4, \, z:1\}, \; z\;\{x:5, \, y:1\}$.
1. $y$ rileva che il costo del collegamento è passato da $4$ a $60$ e calcola il suo nuovo percorso a costo minimo.
2. Ovviamente, con la nostra visione globale della rete, possiamo rilevare che questo nuovo costo attraverso $z$ è errato. Ma l’unica informazione che il nodo $y$ possiede è che il costo diretto verso $x$ è $60$ (e non più $4$) e che $z$ ha ultimamente detto a $y$ di essere in grado di giungere a $x$ con un costo di $5$. Abbiamo, quindi, un instradamento ciclico: al fine di giungere a $x$, $y$ fa passare il percorso per $z$, il quale a sua volta lo fa passare per $y$.
3. $z$ riceve il nuovo vettore delle distanze di $y$,che indica che il costo minimo di $y$ verso x è $6$, sa che può giungere a $y$ a costo $1$ e quindi calcola un nuovo costo minimo verso $x$ pari a $D_z(x) = min\{50 + 0, 1 + 6\} = 7$. Dato che il costo minimo di $z$ verso $x$ è aumentato, $z$ informa $y$ del suo nuovo vettore delle distanze.
4. Analogamente, dopo aver ricevuto il nuovo vettore delle distanze di $z$, $y$ determina $D_y(x) = 8$ ed invia a $z$ il suo nuovo vettore delle distanze; $z$ allora determina $D_z(x) = 9$ e invia a $y$ il suo nuovo vettore delle distanze, e così via.

Il questo specifico caso, il tutto proseguirà per $44$ iterazioni (scambi di messaggi tra $y$ e $z$), fino a quando $z$ considera il costo del proprio percorso attraverso $y$ maggiore di $50$. Tuttavia, cosa sarebbe successo se il costo fosse aumento per un valore molto maggiore rispetto $60$? Questo è il **problema del conteggio all'infinito**.
L’idea è semplice: se $z$ instrada tramite $y$ per giungere alla destinazione $x$, allora $z$ avvertirà $y$ che la sua distanza verso $x$ è infinita, ossia $z$ comunicherà a $y$ che $D_z(x) = +\infty$, anche se in realtà $z$ sa che $D_z(x) = 5$, e continuerà a dire questa piccola bugia fintanto che instrada verso $x$ passando per $y$.

Qual è la **soluzione** al problema? Soluzione al problema descritto è data da **Poison Reserve**. Attraverso quest'ultimo si evita la diffusione di informazioni false utilizzando ...

> Esiste una configurazione in cui Poisoned Reverse non risolve il problema del conteggio all'infinito? Sì, in tutte quelle configurazioni in cui esistono cicli che non riguardano semplicemente due nodi adiacenti.

### Link State
In un instradamento link-state la topologia di rete e tutti i costi dei collegamenti sono noti, ossia disponibili in input all’algoritmo. Ciò si ottiene facendo inviare a ciascun nodo pacchetti sullo stato dei suoi collegamenti a tutti gli altri nodi della rete.
L’algoritmo di calcolo dei percorsi che presentiamo associato all’instradamento link- state è noto come **algoritmo di Dijkstra**.
L’algoritmo di Dijkstra calcola il percorso a costo minimo da un nodo (l’origine, che chiameremo u) a tutti gli altri nodi nella rete, è iterativo e ha le seguenti proprietà: dopo la $k-esima$ iterazione, i percorsi a costo minimo sono noti a $k$ nodi di destinazione e, tra i percorsi a costo minimo verso tutti i nodi di destinazione, questi k percorsi hanno i $k$ costi più bassi. L’algoritmo di instradamento *link-state* consiste in un passo di inizializzazione seguito da un ciclo che viene eseguito una volta per ogni nodo del grafo. Quando termina, l’algoritmo avrà calcolato il percorso minimo dal nodo origine $u$ a tutti gli altri nodi.

### Confronto tra LS e DV
| Distance Vector | Link State | 
|--|--|
| **Decentralizzato**, poiché ogni nodo esegue autonomamente il calcolo per i costi minimi | **Globale**, poiché si basa sulla "*fotografia*" dell'intero grafo (i.e. rete) |
| Basato su **messaggi** provenienti dai soli nodi **vicini** | Basato su **messaggi** provenienti da ogni nodo nel **sistema** (i.e. broadcast) |
| **Informazioni** riguardanti ogni nodo | **Informazioni** riguardanti solo i propri link |
| Problema del **conteggio all'infinito** | Problema delle **oscillazioni** | 
| Invio di un **messaggio** all'aggiornamento della propria **tabella** | Invio **periodico** di un **messaggio** |
| Poco robusto agli **attacchi** | Robusto agli **attacchi** (e.g. dirottare il traffico) | 

### RIP
Il protocollo **RIP** (acronimio di *Routing Information Protocol*) è basato su **Distance Vector** ed utilizza gli **hop** come metrica per il calcolo del peso di un arco nel grafo, ossia il numero di salti effettuati da un nodo all’altro. Si noti che RIP non tiene conto della situazione del singolo link.
Esistono due **versioni** di RIP:
- **RIPv1**, descritta all'interno di $RFC \; 1058$, prevede un numero massimo di salti pari a $15$, il che pone anche un limite al diametro del grafo, utile a velocizzare la convergenza. Secondo RIPv1, le tabelle di routing vengono scambiate ogni $30 \, sec$; se un percorso non viene aggiornato per un tempo maggiore di $180 \, sec$, la sua distanza è settata ad $\infty$. Passati altri $120 \, sec$ dal set ad $\infty$ scatta il *Garbage-Collection Timer*, per cui il nodo irraggiungibile viene eliminato dalla tabella di routing.
	All'interno di RIP, esistono due **tipi di messaggi** per RIPv1:
	- *REQUEST*, per chiedere informazioni ai nodi adiacenti;
	- *RESPONSE*, per inviare informazioni di routing;

	Cosa contiene una **tabella** di routing secondo RIPv1? Ogni tabella contiene:
	- Un indirizzo di destinazione;
	- Una distanza dalla destinazione in *hop*;
	- Un parametro *Next-Hop* uguale al router adiacente;
	- Un *timeout*, un timer;
	- Un *Garbage-Collection Timer*;
- **RIPv2**, descritta all'interno di $RFC \; 2453$, include il trasporto delle informazioni sulla maschera di sottorete, supportando così il CIDR (Classless Inter-Domain Routing). Per garantire la sicurezza degli aggiornamenti sono disponibili 2 metodi: autenticazione semplice con testo in chiaro ed MD5. Per mantenere la retrocompatibilità il limite di *hop count* rimane a $15$;

### OSPF
Il protocollo **OSPF** (acronimo di *Open Shortest Path First*) è basato su **Link State** e consente l'uso di differenti metriche per il calcolo del peso di un arco nel grafo.
Ogni nodo invia un messaggio ad un nodo vicino, rimanendo in attesa della risposta. In base al tempo della risposta il nodo può determinare la bontà del link. Il tempo di risposta, chiaramente, tiene conto *anche* di quanto traffico c’è nel link.
Inoltre, il tutto avviene contemporaneamente tra i due nodi, il che permette di bloccare eventuali imbrogli.

In seguito, ogni nodo prepara poi una sua tabella con i costi determinati per ogni suo link. La tabella viene poi inviata in **flooding** verso gli altri nodi del sistema. Si noti che la tabella è accompagnata da un ID, il quale permette che l'invio di quest'ultima all'interno della rete *non* tenda a crescere fino ad inondare l'intera rete, con la possibilità che possa pure tornare al nodo di origine.
Pur mantenendo un ID, se non fermato in tempo, il flooding potrebbe congestionare la rete.
Per questo motivo utilizziamo **LSA** (acronimo di Link State Advertisement), ovvero informazioni di instradamento inviate via broadcast ogni qualvolta che si verifica un cambiamento nello stato di un link (e.g. una variazione di costo o un cambiamento di disponibilità) a tutti gli altri router nel sistema autonomo. 

Quali sono i tipi di **messaggi** in OSPF? 
Rispetto i messaggi in OSPF, distinguiamo $3$ tipologie:
- **HELLO**, utile a scoprire e verificare i vicini;
- **EXCHANGE**, utile alla sincronizzazione iniziale del DB;
- **FLOODING**, utile all'aggiornamento del DB.

### BGP
Il protocollo BGP è un protocollo di routing tra AS, cui scopo è realizzare dorsali di comunicazioni basate a partire da motivazioni che possono essere anche politiche. 
Ogni AS possiede uno o più ASBR, ossie di router di bordo in grado di mettere in comunicazione due AS. Il protocollo BGP viene eseguito sui BGP Speaker, i quali non sono necessariamente dei ASBR.



